# (PART) Intermediate R  {-}


# Functionals {#functionals}

## The `apply` family

The `apply` family are examples of functionals, functions that take a function as an input and return a vector as output.
They are an alternative to loops.
The members of the family differ in the kind of input and output they use / return

## `apply`

The `apply` function operates on matrices (in general, on arrays, but we'll only use 2D arrays, i.e., matrices).  
The generic call is

```r
apply(X, MARGIN, FUN, ...)`
```

- `X` is the object to which we want to apply the function.
- `MARGIN` is the dimension of the matrix (array) to be used in the calculation. `MARGIN=1` makes the function apply to rows of `X` while `MARGIN=2` makes the function apply to columns of `X`.
- `FUN` is a function to be applied, which can also be defined by the user.
- `...` stands for possible further arguments.

Importantly, notice that the function called in `apply` **applies to a vector**.  
The following examples illustrate the use of this function.
```{r}
# create a matrix
myM  <- matrix(floor(runif(30)*20), nrow=5, ncol=6)
myM 
# sum of rows
sofr <- apply(myM , 1, sum)  
sofr
# standard deviation of columns
sdofc <- apply(myM , 2, sd)  
sdofc
```

The dimension of the return is non-trivial, though understandable after careful examination.
```{r}

sqrtofr <- apply(myM , 1,sqrt) ## careful with the dimension of the output; 
sqrtofr
```

The function can be defined by the user.
```{r}
# define own function; e.g., take the max of the vector and add 100 
myf <- function(k) { 
  max(k)+100
}

myfofr <- apply(myM ,1,myf)
myfofr

```

Notice that the function can also be defined inside the `apply` function (not recommended, though).
```r
dofc <- apply(myM , 2, function(k) max(k)+1)
```

### Extra argument `...`

The extra argument `...` serves as a placeholder for further arguments to be passed to the function. Here is an example that requires the extra argument `n`. 

```{r}
# define a function that requires two arguments
myf2 <- function(k,n){
  max(k) + n
}

myf2ofr <- apply(myM, 1, myf2, 25)
myf2ofr
```

Notice that if `n` was defined in the global environment, then it would be used as default in the previous.


## `lapply`

`lapply` applies a given function to every element of a list and returns a list as result. Of course, it can also be applied to a vector.  
The generic call is

```r
apply(X, FUN, ...)`
```

- `X` is the **list** to which we want to apply the function.
- `FUN` is a function to be applied to each element of the list which can also be defined by the user.  
- `...` stands for possible further arguments.


Here is an example.

```{r}
# first, create a list on which apply the functions
mylist<- list(numbers=c(1:20), 
              cities=c("Cologne","Lisbon"), 
              results= c(T,F,F,T), 
              school=factor(c("Primary", "Secondary", "Tertiary"), ordered=TRUE))

# list of lengths 
lofl <- lapply(mylist, length) 
lofl

# unlist a list gives, if possible, a vector
vofl <- unlist(lapply(mylist, length)) 
vofl
```

This other example shows that indeed anything that happens in R, including `[`, is a function.

```{r}
## "[" is the function of subsetting, 2 is the argument to that function,
## hence, this gives the second element of each element of mylist
sofl <- lapply(mylist,"[",2) 
sofl
```

Alternatively, we can also define a function for subsetting before making the `lapply` call.
```r
mysubset <- function(x,n) {
  x[n]
}

sofl <- lapply(mylist, mysubset, 2) 
```



## `sapply`

`sapply` works like `lapply` but tries to return a simplified version.

The same example as above.
```{r}
mylist<- list(numbers=c(1:20), 
              cities=c("Cologne","Lisbon"), 
              results= c(T,F,F,T), 
              school=factor(c("Primary", "Secondary", "Tertiary"), ordered=TRUE))

# vector of lengths 
sofl2 <- sapply(mylist, length) 
sofl2
```

Another example, this time applied on a vector of a list. 
```{r}
sd2ofl <- sapply(mylist$numbers, function(x) x^2 /2 )

```



## Multicore implementation

The `apply()` family runs, by nature, "embarrassingly parallel tasks". As it turns out, it is very easy on Mac to exploit parallelism.

```{r}
library(parallel)
cores <- detectCores()
cores
# the function Sys.sleep(n) makes the computer sleep for the n seconds
system.time(lapply(1:4, function(x) Sys.sleep(1)))
system.time(mclapply(1:4, function(x) Sys.sleep(1), mc.cores = cores ))
```






