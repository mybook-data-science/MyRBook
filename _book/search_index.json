[
["index.html", "Learning Data Science in R Foreword", " Learning Data Science in R Antonio Fidalgo Last update: March 25, 2019 Foreword “Data science is like teenage sex: everyone talks about it, nobody really knows how to do it, everyone thinks everyone else is doing it, so everyone claims they are doing it…” — paraphrase of Dan Ariely’s quote on big data There is already a large number of excellent and free references for learning data science in R. The list would be too vast, but two names stand out: Hadley Wickham and Yihui Xie. Work of the first includes the books Wickham and Grolemund (2016) and Wickham (2014) (freely available, including source code, on github.com/hadley) as well as some of the most popular packages in R such as ggplot2 (Wickham et al. 2018) and tidyverse(Wickham 2017). Work of the second is used precisely in the current file thanks to the rmarkdown package (Allaire et al. 2018), knitr (Xie 2018b) and bookdown (Xie 2018a). His source code is also on github.com/yihui/. So, the question arises of why one should even bother to write on the topic. The present “book” is justified on the following grounds. There is no better way of learning data science and R than doing oneself the pages of code. The material gathered here is a personal selection made on what I judge most relevant for my work, the most important techniques in general or, sometimes, the least obvious for the regular practitioner. These notes serve as an archive of what I did in the domain so that I can easily access it in the future. References "],
["getset.html", "Chapter 1 Getting set 1.1 Install applications 1.2 Sign for GitHub 1.3 Create your project 1.4 Create GitHub repo and link your machine to it 1.5 Collaboration on GitHub", " Chapter 1 Getting set 1.1 Install applications Download the following free applications, available on all platforms: R RStudio, free Desktop version A Latex distribution (e.g., MacTex for Mac or MiKTeX for Windows machines) The first two are easily and quickly installed. The last is a very large program (a few Gb) and needs time to install. Another application needed is a Git distribution This is also a free software. Once you have installed Git for version control, activate it in RStudio: Tools&gt; Global Options&gt; Git/SVN and click on Enable version control interface for RStudio projects. Also generate a SHH RSA key. We will use it to identify at the GitHub repo. 1.2 Sign for GitHub Create an account at GitHub at https://github.com. 1.3 Create your project File&gt; New project&gt; Existing Directory and chose that book folder. Now, every time you create content for your book, you must start a Rstudio session File&gt; Open Project… All the files of the project are the files of the folder, and vice versa. 1.4 Create GitHub repo and link your machine to it Create a new repository (pronounced ‘repo’) whose name is exactly the same as your R project / book folder (e.g., ‘myRbook’). On the top left menu in GitHub, go to Settings&gt; SHH and GPG keys and click on ‘New SHH key’. Paste the SHH key generated by RStudio. In RStudio go to Tools&gt; Project Options…&gt; Git/SVN. Under Version control system, select ‘Git’. Still in RStudio, Tools&gt; Terminal&gt; New Terminal. This open a Terminal where you type commands. Start by initializing Git on the terminal. git init Then paste the message shown at the creation of the repo (changing the names, of course): git remote add origin https://github.com/YOURNAME/YOURREPO.git git push -u origin master Your local master should now be connected to the master on GitHub. If necessary, restart RStudio. At the restart, a Git thumbnail should appear in a pane. You are ready to commit and push your files. 1.4.1 Troubleshooting If the procedure above works, great! One must be aware, however, that it sometimes hits some problem unexpected and difficult to understand problem. In these cases, a classic solution is to copy and google the error message with a first term such as “RStudio”. In my experience, the following hack worked. Find the invisible file of the repo .git&gt; config. Hidden files on Mac are turned visible by the keyboard key CMD + SHIFT + .. In that file, delete the following part (including the space it takes) [remote &quot;origin&quot;] url = git@github.com:USERNAME/repo.git fetch = +refs/heads/*:refs/remotes/origin/* Then, try again the procedure above. 1.5 Collaboration on GitHub There are various established ways for collaborating on a GitHub repo. As a matter of facts, collaboration on a project is the raison d’etre of GitHub. We illustrate here the easiest of them, namely the joint reading and writing into one repo by all the members of a team. Importantly, it is assumed that all members of the group are able to push/pull code from RStudio to an experimental repo on GitHub (see above). The following are the steps in the collaboration’s setup. 1.5.1 Owner of the organization One member of the group creates an organization on GitHub under Settings&gt; Organizations&gt; New organization. Then, under that organization, this member of the team creates a new repo whose name is the same as the folder and R project that the group will work on (e.g., ‘ouRbook’). The owner of the organization connects from RStudio to the repo and populates it with the current files of the project. Still as a task of the owner, create a team. Under the organization page in GitHub, simply click on ‘New team’ and give it a name. A team now appears in the organization page. In the page of that team, click on ‘Add a member’. A window appears where the member to be added can be searched for and added. Once that member is found and selected, make the double step of adding him/her to the team AND assign him/her to the repo. This second step can still be made later, but it’s simpler to do it right then. Importantly, make sure that the new member has reading and writing rights into the repo. This again, can be changed later by navigating the team’s page. 1.5.2 Member of the team After the steps above, the newly added member receives an email to confirm the participation the organization / team. Navigate now to the team’s page and locate the repo that the owner has created. A button-menu allows to ‘Clone or download the repo’. Click to show the https address of the repo, https://github.com/ORGANIZATION/team.git and copy that link. Open a simple RStudio session (not a project!). Open a new Terminal (Tools&gt; Terminal&gt; New Terminal) and type cd (change directory) and a path to the folder where you want the repo to be saved. For instance, cd Dropbox/Fresenius/DS4B The terminal is writing into that folder, as indicated by the path before the $ sign in command line of the terminal. Recall that you copied the address of the team’s repo. Then, in command line, now type the following commands and your copied address: git clone https://github.com/ORGANIZATION/team.git The whole repo is now a new folder in your directory. If all went well, you can now pull and push into that repo in GitHub. "],
["rmd.html", "Chapter 2 Rmd files 2.1 Options for all chuncks 2.2 Latex code", " Chapter 2 Rmd files This chapter gathers general comments about .Rmd files. 2.1 Options for all chuncks It is convenient to set options for all the R chuncks of the document. This saves time when writing these chuncks. A natural place to set these options is in a first R chunck. knitr::opts_chunk$set(OPTION1 = TRUE/FALSE, OPTION2 = TRUE/FALSE, ...) Importantly, these options are overriden by the particular chunck options. ```{r, OPTION2=FALSE} Options actually take R code. So, the following are examples that could be used to define the option. ```{r, eval=4&gt;3, echo=format(Sys.Date(), &#39;%Y-%B-%d&#39;) &gt; &#39;2019-March-10&#39;} # eval is always TRUE # echo = TRUE if current date is after March 10, 2019 ``` The list of options can be found here https://yihui.name/knitr/options/. Below are some comments on some of these options (the least trivial for the author). collapse determines whether the source code and the ouput should be merged into a single block. Here is the same chunck with different values of the option: collapse=TRUE 2+ 2 #&gt; [1] 4 3* 5 #&gt; [1] 15 collapse=FALSE 2+ 2 #&gt; [1] 4 3* 5 #&gt; [1] 15 comment gives the string to be printed before the output. comment='##' 2+ 2 ## [1] 4 comment='R&gt;' 2+ 2 R&gt; [1] 4 Worth noting: a # as a first character of the comment string (with collpase=TRUE) turns the output font into a comment-like text. child allows a document to call and use another file as input in the document. ```{r, child=&#39;PATH/TO/OTHER/file.Rmd&#39;} The path can be either absolute or relative. For relative paths, the following applies: ~/ starts a path a the root, ../ indicates the parent directory, ../../ for parent of the parent directory, to move forward, start with the name of the included folder in the current directory. 2.2 Latex code The overwhelming reason to introduce Latex code in a .Rmd file is for typesetting mathematical expressions. There are two main ways to type math in Latex: in the text, surrounded by special delimiters, \\( math \\) (alternatively, one can use the deprecated $ math $), in an equation, surrounded by special delimiters, \\[ math equation \\], or in a dedicated environment such as \\begin{equation} math equation \\end{equation} (also deprecated, $$ math equation $$). [ Complete here with: . examples of inline code and an equation, . a reference for Latex, . maybe the drawing interpreter. ] "],
["custom-ouptut.html", "Chapter 3 Customize output 3.1 Multiple built-in output types 3.2 New types provided by packages 3.3 CSS: custom html 3.4 Latex preamble", " Chapter 3 Customize output This chapter is about choosing and/or modifying the way the output file looks like. 3.1 Multiple built-in output types [complete this section] From pdf to slides, through webpages and notebooks. 3.2 New types provided by packages [complete this section] These are more variations of the above. 3.3 CSS: custom html A file to change how html outputs look like. 3.4 Latex preamble This file is added to the preamble of the Latex file to modify how the pdf output is compiled. "],
["rcalc.html", "Chapter 4 R as a calculator 4.1 Usual operators 4.2 Unusual operators 4.3 Usual functions", " Chapter 4 R as a calculator R can be used as a simple calculator. For instance, 45+17=62 . Here are a few more examples of the commands. 4.1 Usual operators 4.1.1 Simple operations The usual symbols +, -, *, / apply . 2 + 6 #&gt; [1] 8 56/ 6 #&gt; [1] 9.333333 4.1.2 Parentheses The parentheses work as expected. But they are also a common source of error when they are not matched. (4+3)*((7-3)/(1+.05)) #&gt; [1] 26.66667 The next expression will generate an error and prevent the compilation of the whole book. (4+3)*((7-3/(1+.05)) 4.1.3 Exponents There are two ways of expressing the power of a number: ^ and **. 3^4 #&gt; [1] 81 3**4 #&gt; [1] 81 4.2 Unusual operators 4.2.1 Special operations The symbols %/% and %% return the entire part of the result of the division and the rest of the division, respectively. 56/6 #&gt; [1] 9.333333 56%/%6 #&gt; [1] 9 56%%6 #&gt; [1] 2 4.3 Usual functions The common functions found in any calculator also have an equivalent on R. The following examples need no further comment. log(100) #&gt; [1] 4.60517 sqrt(100) #&gt; [1] 10 "],
["datastructures.html", "Chapter 5 Data stuctures 5.1 Atomic vectors 5.2 Matrices and arrays 5.3 Lists 5.4 Data frames", " Chapter 5 Data stuctures This chapter lists the most common objects to store data. 5.1 Atomic vectors The basic data structure in R is the vector. Vectors have three characteristics: a type, typeof(), a length, length(), some attributes, attributes(). 5.1.1 Types of data There are four common types of atomic vectors: logical, integer, double (often called numeric), character. Note that if vector elements not all of the same type, R makes coercion. In that case, the order becomes: “logical &lt; numeric &lt; character”. Here are a few illustrations. trop1 &lt;- c(24, 23, 23, 24, 24) trop1 #&gt; [1] 24 23 23 24 24 trop2 &lt;- c(&quot;mi&quot;, &quot;ga&quot;, &quot;tr&quot;, &quot;ba&quot;, &quot;ha&quot;) trop2 #&gt; [1] &quot;mi&quot; &quot;ga&quot; &quot;tr&quot; &quot;ba&quot; &quot;ha&quot; trop3 &lt;- c(24, 24, &quot;trierweiler&quot;) trop3 #&gt; [1] &quot;24&quot; &quot;24&quot; &quot;trierweiler&quot; typeof(trop3) #&gt; [1] &quot;character&quot; var &lt;- c(2) var #&gt; [1] 2 tar &lt;- c(&quot;2&quot;) tar #&gt; [1] &quot;2&quot; var + 30 #&gt; [1] 32 #tar + 30 log_vector &lt;- c(TRUE, FALSE, FALSE) int_vector &lt;- c(12, 10, 3, &quot;tre&quot;) typeof(int_vector) #&gt; [1] &quot;character&quot; int_vector &lt;- c(12L, 10L, 3L) typeof(int_vector) #&gt; [1] &quot;integer&quot; num_vector &lt;- c(12, 10, 3) typeof(num_vector) #&gt; [1] &quot;double&quot; chr_vector &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) typeof(chr_vector) #&gt; [1] &quot;character&quot; is.numeric(num_vector) #&gt; [1] TRUE no_vector &lt;- c(2, &quot;a&quot;) is.numeric(no_vector) #&gt; [1] FALSE typeof(no_vector) #&gt; [1] &quot;character&quot; vector_A &lt;- c(1:5) vector_A #&gt; [1] 1 2 3 4 5 length(vector_A) #&gt; [1] 5 5.1.2 Factor vector This is a special type of vector. It has a limited number of values, called levels. These levels can be unordered (e.g., gender is either “Female” or “Male”) or ordered (e.g. school level is “Primary”, “Secondary”, “Tertiary”) gender &lt;-factor(c(&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;)) gender #&gt; [1] Male Male Female Male Female Female Male #&gt; Levels: Female Male levels(gender) #&gt; [1] &quot;Female&quot; &quot;Male&quot; summary(gender) #&gt; Female Male #&gt; 3 4 school&lt;-factor(c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;), ordered=TRUE) school #&gt; [1] Primary Secondary Tertiary #&gt; Levels: Primary &lt; Secondary &lt; Tertiary school2&lt;-factor(c(&quot;Primary&quot;, &quot;Secondary&quot;,&quot;Secondary&quot;, &quot;Tertiary&quot;), labels=c( &quot;Secondary&quot;, &quot;Tertiary&quot;,&quot;Primary&quot;), ordered=TRUE) school2 #&gt; [1] Secondary Tertiary Tertiary Primary #&gt; Levels: Secondary &lt; Tertiary &lt; Primary 5.2 Matrices and arrays My experience is that R is not often used for matrices calculations: it is too slow for that, that are better programs for that out there (e.g. Matlab). M &lt;- matrix(c(4, 1, 0, 3, 6, 8), nrow=3, ncol=2) M #&gt; [,1] [,2] #&gt; [1,] 4 3 #&gt; [2,] 1 6 #&gt; [3,] 0 8 If we think of a matrix as a 2 dimensions vector, then arrays are \\(n\\) dimensions vectors. Is it important? Probably in some cases, not so much for us. mya&lt;-array(data=1:18, dim=c(2,3,3)) mya #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 13 15 17 #&gt; [2,] 14 16 18 5.3 Lists These are the one-size fit all structure… A list is an object composed of any other object, even… another list! Very useful data structure! school&lt;-factor(c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;), ordered=TRUE) mylist &lt;- list(numbers=c(1:60), somenames=c(&quot;Jim&quot;,&quot;Jules&quot;), results= c(T,F,F,T), school=school) mylist #&gt; $numbers #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #&gt; [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #&gt; [47] 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; #&gt; $somenames #&gt; [1] &quot;Jim&quot; &quot;Jules&quot; #&gt; #&gt; $results #&gt; [1] TRUE FALSE FALSE TRUE #&gt; #&gt; $school #&gt; [1] Primary Secondary Tertiary #&gt; Levels: Primary &lt; Secondary &lt; Tertiary names(mylist) &lt;- c(&quot;N&quot;, &quot;O&quot;,&quot;R&quot;,&quot;S&quot;) 5.4 Data frames The second most important data structure in R. You can think of it as a better version of a data set in Excel. It stacks together observations over many variables, each of these variables being a vector. data(mtcars) class(mtcars) #&gt; [1] &quot;data.frame&quot; mtcars #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 #&gt; Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 head(mtcars) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 str(mtcars) #&gt; &#39;data.frame&#39;: 32 obs. of 11 variables: #&gt; $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... #&gt; $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... #&gt; $ disp: num 160 160 108 258 360 ... #&gt; $ hp : num 110 110 93 110 175 105 245 62 95 123 ... #&gt; $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... #&gt; $ wt : num 2.62 2.88 2.32 3.21 3.44 ... #&gt; $ qsec: num 16.5 17 18.6 19.4 17 ... #&gt; $ vs : num 0 0 1 1 0 1 0 1 1 1 ... #&gt; $ am : num 1 1 1 0 0 0 0 0 0 0 ... #&gt; $ gear: num 4 4 4 3 3 3 3 4 4 4 ... #&gt; $ carb: num 4 4 1 1 2 1 4 2 2 4 ... names(mtcars) # names of the variables in the data frame #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; length(mtcars) #&gt; [1] 11 str(mtcars) #&gt; &#39;data.frame&#39;: 32 obs. of 11 variables: #&gt; $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... #&gt; $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... #&gt; $ disp: num 160 160 108 258 360 ... #&gt; $ hp : num 110 110 93 110 175 105 245 62 95 123 ... #&gt; $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... #&gt; $ wt : num 2.62 2.88 2.32 3.21 3.44 ... #&gt; $ qsec: num 16.5 17 18.6 19.4 17 ... #&gt; $ vs : num 0 0 1 1 0 1 0 1 1 1 ... #&gt; $ am : num 1 1 1 0 0 0 0 0 0 0 ... #&gt; $ gear: num 4 4 4 3 3 3 3 4 4 4 ... #&gt; $ carb: num 4 4 1 1 2 1 4 2 2 4 ... "],
["simple-functions-on-vectors.html", "Chapter 6 Simple functions on vectors", " Chapter 6 Simple functions on vectors In this section, we illustrate calculations with a single vector (element by element) and the recycling rule. visits1 &lt;- c(12, 2, 45, 75, 65, 11, 3) visits2 &lt;- c(23, 4, 5, 78, 12, 0, 200) total &lt;- visits1 + visits2 total #&gt; [1] 35 6 50 153 77 11 203 total.p2 &lt;- total^2 total.p2 #&gt; [1] 1225 36 2500 23409 5929 121 41209 apples &lt;- 15 bananas &lt;- 60 my.fruits &lt;- apples + bananas my.fruits #&gt; [1] 75 l3 &lt;- c(12, 34, 50) l2 &lt;- c(10, 3) tt &lt;- l3 + 5 tt #&gt; [1] 17 39 55 ltotal &lt;- l3+l2 # recycling!!! #&gt; Warning in l3 + l2: longer object length is not a multiple of shorter #&gt; object length ages &lt;- c(28, 33, 39, 56, 34, 45, 27, 40) ages #&gt; [1] 28 33 39 56 34 45 27 40 max(ages) #&gt; [1] 56 sum(ages) #&gt; [1] 302 length(ages) #&gt; [1] 8 ages &lt;- c(28, 33,39,56,34,45, 27,40, NA) mean(ages, na.rm=TRUE) #&gt; [1] 37.75 # for help on a command, simply type ? in front of it ?mean "],
["subset.html", "Chapter 7 Subsetting 7.1 Generalities about subsetting 7.2 [] 7.3 [[]] 7.4 $ 7.5 Combining subsetting 7.6 Subsetting with one condition 7.7 Subsetting and assignment 7.8 Using which() 7.9 More advanced stuff", " Chapter 7 Subsetting 7.1 Generalities about subsetting There are three subsetting operators: $, [] and [[]]. Some functions also allow to create subsets: we’ll see that later. We can combine subsetting and assignment to change some parts of an object. Complement to str(). va &lt;- c(13.1, -15.2, 0.3, 2.4, 10.5, -3.6, 9.7) # create the vector va str(va) #&gt; num [1:7] 13.1 -15.2 0.3 2.4 10.5 -3.6 9.7 One can see from this call, that va is a simple vector with r length(va) elements. Subsetting means chosing among these. 7.2 [] Applies to vectors, matrices, lists and data frames. Can be used with: - positive or negative values, - many values in a vector, - logical, `NA`, - character vectors when names. 7.2.1 On a vector Here are a few examples of that object used on a vector. va &lt;- c(13.1, -15.2, 0.3, 2.4, 10.5, -3.6, 9.7) va[1] # element 1 #&gt; [1] 13.1 va[c(3:5)] # elements 3 to 5 #&gt; [1] 0.3 2.4 10.5 va[-1] # all elements minus the element 1 #&gt; [1] -15.2 0.3 2.4 10.5 -3.6 9.7 va[c(TRUE,TRUE,TRUE,FALSE,FALSE,TRUE,FALSE)] #&gt; [1] 13.1 -15.2 0.3 -3.6 va[c(TRUE,FALSE)] # notice the recycling at play here #&gt; [1] 13.1 0.3 10.5 9.7 va[NA] #&gt; [1] NA NA NA NA NA NA NA va[] # nothing selected gives the full vector #&gt; [1] 13.1 -15.2 0.3 2.4 10.5 -3.6 9.7 names(va)&lt;-letters[1:length(va)] # give names to va # notice that we subset the vector letters (given by R) and that we don&#39;t # specify the length but give a general value # now we can subset using names va #&gt; a b c d e f g #&gt; 13.1 -15.2 0.3 2.4 10.5 -3.6 9.7 va[c(&quot;a&quot;,&quot;e&quot;,&quot;b&quot;)] #&gt; a e b #&gt; 13.1 10.5 -15.2 7.2.2 On a list mylist&lt;- list(numbers=c(1:20), ournames=c(&quot;Jim&quot;,&quot;Jules&quot;), results= c(T,F,F,T), school=factor(c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;), ordered=TRUE)) str(mylist) #&gt; List of 4 #&gt; $ numbers : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ ournames: chr [1:2] &quot;Jim&quot; &quot;Jules&quot; #&gt; $ results : logi [1:4] TRUE FALSE FALSE TRUE #&gt; $ school : Ord.factor w/ 3 levels &quot;Primary&quot;&lt;&quot;Secondary&quot;&lt;..: 1 2 3 mylist[1] # first element of the list #&gt; $numbers #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class(mylist[1]) #&gt; [1] &quot;list&quot; mylist[[3]][3] #&gt; [1] FALSE Notice that the result of this subsetting is a r class(mylist[1])! 7.2.3 On a matrix set.seed(42) my.mat &lt;- matrix(floor(runif(30)*10), nrow=5) my.mat #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 9 5 4 9 9 5 #&gt; [2,] 9 7 7 9 1 3 #&gt; [3,] 2 1 9 1 9 9 #&gt; [4,] 8 6 2 4 9 4 #&gt; [5,] 6 7 4 5 0 8 str(my.mat) #&gt; num [1:5, 1:6] 9 9 2 8 6 5 7 1 6 7 ... length(my.mat) #&gt; [1] 30 The structure shows that there are r length(dim(my.mat)) dimensions. For subsetting, we must give r length(dim(my.mat)) dimensions! Same rules as for the vectors apply. my.mat[2,3] # 2nd row, 3rd row #&gt; [1] 7 my.mat[-1,] #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 9 7 7 9 1 3 #&gt; [2,] 2 1 9 1 9 9 #&gt; [3,] 8 6 2 4 9 4 #&gt; [4,] 6 7 4 5 0 8 colnames(my.mat) &lt;- letters[1:ncol(my.mat)] # give names to the columns rownames(my.mat) &lt;- LETTERS[1:nrow(my.mat)] # give names to the rows my.mat #&gt; a b c d e f #&gt; A 9 5 4 9 9 5 #&gt; B 9 7 7 9 1 3 #&gt; C 2 1 9 1 9 9 #&gt; D 8 6 2 4 9 4 #&gt; E 6 7 4 5 0 8 my.mat[&quot;C&quot;,c(&quot;a&quot;,&quot;c&quot;,&quot;e&quot;)] #&gt; a c e #&gt; 2 9 9 7.3 [[]] This object is used mainly for lists. mylist&lt;- list(numbers=c(1:20), ournames=c(&quot;Jim&quot;,&quot;Jules&quot;), results= c(T,F,F,T), school=factor(c(&quot;Primary&quot;, &quot;Secondary&quot;, &quot;Tertiary&quot;), ordered=TRUE)) str(mylist) #&gt; List of 4 #&gt; $ numbers : int [1:20] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ ournames: chr [1:2] &quot;Jim&quot; &quot;Jules&quot; #&gt; $ results : logi [1:4] TRUE FALSE FALSE TRUE #&gt; $ school : Ord.factor w/ 3 levels &quot;Primary&quot;&lt;&quot;Secondary&quot;&lt;..: 1 2 3 mylist[[1]] #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 7.4 $ This object is usually for data frames, where it gives the variable. It allows partial matching (e.g., mtcars$gear is the same as mtcars$gea) data(mtcars) names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; mtcars$mpg #&gt; [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 #&gt; [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 #&gt; [29] 15.8 19.7 15.0 21.4 mtcars[[&quot;mpg&quot;]] # just exactly the same, but R users prefer the $ #&gt; [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 #&gt; [15] 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 #&gt; [29] 15.8 19.7 15.0 21.4 mtcars[&quot;mpg&quot;] # NOT the same at all! [] preserves the class #&gt; mpg #&gt; Mazda RX4 21.0 #&gt; Mazda RX4 Wag 21.0 #&gt; Datsun 710 22.8 #&gt; Hornet 4 Drive 21.4 #&gt; Hornet Sportabout 18.7 #&gt; Valiant 18.1 #&gt; Duster 360 14.3 #&gt; Merc 240D 24.4 #&gt; Merc 230 22.8 #&gt; Merc 280 19.2 #&gt; Merc 280C 17.8 #&gt; Merc 450SE 16.4 #&gt; Merc 450SL 17.3 #&gt; Merc 450SLC 15.2 #&gt; Cadillac Fleetwood 10.4 #&gt; Lincoln Continental 10.4 #&gt; Chrysler Imperial 14.7 #&gt; Fiat 128 32.4 #&gt; Honda Civic 30.4 #&gt; Toyota Corolla 33.9 #&gt; Toyota Corona 21.5 #&gt; Dodge Challenger 15.5 #&gt; AMC Javelin 15.2 #&gt; Camaro Z28 13.3 #&gt; Pontiac Firebird 19.2 #&gt; Fiat X1-9 27.3 #&gt; Porsche 914-2 26.0 #&gt; Lotus Europa 30.4 #&gt; Ford Pantera L 15.8 #&gt; Ferrari Dino 19.7 #&gt; Maserati Bora 15.0 #&gt; Volvo 142E 21.4 class(mtcars[&quot;mpg&quot;]) #&gt; [1] &quot;data.frame&quot; 7.5 Combining subsetting Notice that we can often subset further until having the desired subset. Here are a few examples. mtcars$mpg[1:4] #&gt; [1] 21.0 21.0 22.8 21.4 mylist[[&quot;ournames&quot;]][1] #&gt; [1] &quot;Jim&quot; mylist$ournames[1] #&gt; [1] &quot;Jim&quot; 7.6 Subsetting with one condition We can use conditions for subsetting mtcars[mtcars$cyl==8,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 #&gt; Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 #&gt; Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 mtcars[mtcars$cyl==8 &amp; mtcars$carb==4,] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 #&gt; Cadillac Fleetwood 10.4 8 472 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 #&gt; Camaro Z28 13.3 8 350 245 3.73 3.840 15.41 0 0 3 4 #&gt; Ford Pantera L 15.8 8 351 264 4.22 3.170 14.50 0 1 5 4 mtcars[mtcars$cyl==8, c(&quot;cyl&quot;, &quot;mpg&quot;, &quot;wt&quot;)] #&gt; cyl mpg wt #&gt; Hornet Sportabout 8 18.7 3.440 #&gt; Duster 360 8 14.3 3.570 #&gt; Merc 450SE 8 16.4 4.070 #&gt; Merc 450SL 8 17.3 3.730 #&gt; Merc 450SLC 8 15.2 3.780 #&gt; Cadillac Fleetwood 8 10.4 5.250 #&gt; Lincoln Continental 8 10.4 5.424 #&gt; Chrysler Imperial 8 14.7 5.345 #&gt; Dodge Challenger 8 15.5 3.520 #&gt; AMC Javelin 8 15.2 3.435 #&gt; Camaro Z28 8 13.3 3.840 #&gt; Pontiac Firebird 8 19.2 3.845 #&gt; Ford Pantera L 8 15.8 3.170 #&gt; Maserati Bora 8 15.0 3.570 7.7 Subsetting and assignment Subsetting can be used to change a part of an object through assignment. Assign NULL to delete subset my.mat #&gt; a b c d e f #&gt; A 9 5 4 9 9 5 #&gt; B 9 7 7 9 1 3 #&gt; C 2 1 9 1 9 9 #&gt; D 8 6 2 4 9 4 #&gt; E 6 7 4 5 0 8 my.mat[,1]&lt;-1:nrow(my.mat) my.mat #&gt; a b c d e f #&gt; A 1 5 4 9 9 5 #&gt; B 2 7 7 9 1 3 #&gt; C 3 1 9 1 9 9 #&gt; D 4 6 2 4 9 4 #&gt; E 5 7 4 5 0 8 mtcars$mpg[1]&lt;-1234 names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; mtcars$drat&lt;-NULL # delete variable drat in data frame mtcars # does not delete in matrix names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; &quot;carb&quot; 7.8 Using which() which() gives the integers that correspond to the boolean (logical) TRUE. This can help subsetting vb&lt;-1500:1530 vb #&gt; [1] 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 #&gt; [15] 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 #&gt; [29] 1528 1529 1530 which(vb%%5==0) # which is divisible by 5 (modulo is 0) ? #&gt; [1] 1 6 11 16 21 26 31 # notice that this is asking each element of vb, # which() reports the positions for which the answer is TRUE vb[which(vb%%5==0)] #&gt; [1] 1500 1505 1510 1515 1520 1525 1530 7.9 More advanced stuff 7.9.1 Difference between simplifying and preserving We say ‘preserve’ to say the same structure is maintained when subsetting (e.g., a subset of a data frame remains a data frame). Simplifying does not keep the structure but gives the simplest output possible. drop argument allows to preserve (drop=FALSE) or not (drop= TRUE). [] usually preserves, [[]] usually simplifies. To better understand, check the classes: all.equal(class(mylist[1]), class(mylist[[1]])) #&gt; [1] &quot;1 string mismatch&quot; class(mylist[1]) #&gt; [1] &quot;list&quot; class(mylist[[1]]) #&gt; [1] &quot;integer&quot; all.equal(class(mylist), class(mylist[1])) #&gt; [1] TRUE all.equal(class(mylist), class(mylist[[1]])) #&gt; [1] &quot;1 string mismatch&quot; We see that [] has preserved the class of mylist (r class(mylist)), while [[]] has not! Another striking example is the following. ma2 &lt;- my.mat[1:2,1:3] class(ma2) #&gt; [1] &quot;matrix&quot; ma3 &lt;- my.mat[1,1:3] class(ma3) #&gt; [1] &quot;numeric&quot; ma3 is NOT a matrix anymore!!! This is because one of its dimensions is 1. Losing track of the class when subsetting can generate lots of problems in the middle of a large code. And it is a common source of error! To be sure of keeping the class, we can use drop=FALSE (the class will not be dropped to, usually, a vector). ma4 &lt;- my.mat[1,1:3, drop=FALSE] ma4 #&gt; a b c #&gt; A 1 5 4 class(ma4) #&gt; [1] &quot;matrix&quot; "],
["conditions.html", "Chapter 8 Conditions 8.1 if statement 8.2 else statement 8.3 else if statement 8.4 ifelse statement 8.5 Logical operators: &amp;, | and ! 8.6 Writing and interpreting a condition", " Chapter 8 Conditions The general purpose of conditions is to control the flow of our code when executed by R. In R, it builds on statements such as if and else. 8.1 if statement The simplest form for a condition uses a if statement. The form is then: if (condition) { # code to be executed if the condition is met } The key point is that R will run the code until it finds a condition that is met. If it doesn’t find any, it continues to the next lines of code. Here is an example. gains &lt;- c(10, 3,-5,0,-4,12,4) sum(gains) #&gt; [1] 20 if (sum(gains) &gt; 0) { print(&quot;Congratulations, you are winning!&quot;) } #&gt; [1] &quot;Congratulations, you are winning!&quot; gains[1] &lt;- -10 # change the first element of gains if (sum(gains) &gt; 0) { print(&quot;Congratulations, you are winning!&quot;) } # notice that there is no output, because the condition was not met 8.2 else statement What happens when the condition is not met? It’s on the user to decide. It can be nothing or… something else! if (condition) { # code to be executed if the condition is met } else { # code to be executed if the condition is NOT met } Here is an example. gains&lt;- c(10, 3,-5,0,-4,12,4) gains[1] &lt;- -10 # change the first element of gains sum(gains) #&gt; [1] 0 if (sum(gains) &gt; 0) { print(&quot;Congratulations, you are winning!&quot;) } else { print(&quot;You are not winning!&quot;) } # notice that now there is an output! #&gt; [1] &quot;You are not winning!&quot; 8.3 else if statement else if allows us to introduce another condition to our flow of code if (condition_1) { # code to be executed if the condition_1 is met } else if (condition_2) { # code to be executed if the condition_2 is met } else { # code to be executed if NEITHER condition_1 NOR condition_2 is met } We can use as many else if statements as we want. Here is an example with only one else if gains&lt;- c(10, 3,-5,0,-4,12,4) gains[1] &lt;- -10 # change the first element of gains sum(gains) #&gt; [1] 0 if (sum(gains) &gt; 0) { print(&quot;Congratulations, you are winning!&quot;) } else if (sum(gains)==0) { print(&quot;You just break even!&quot;) } else { print(&quot;You are losing!&quot;) } #&gt; [1] &quot;You just break even!&quot; Notice the potential problem of not putting a else statement at the end of the conditions system. 8.4 ifelse statement For short conditions, we can use ifelse. The form is ifelse(condition, value if condition met, value if value not met) Here is an example. gains &lt;- c(10, 3,-5,0,-4,12,4) sign &lt;- ifelse(sum(gains)&gt;=0,&quot;+&quot;,&quot;-&quot;) sign #&gt; [1] &quot;+&quot; 8.5 Logical operators: &amp;, | and ! Logical operators are used to combine, mix or negate several conditions: - &amp; means AND - | means OR - ! means NOT De Morgan’s laws may help here. (10%%2==0 &amp; 27%%3==0) # equivalent to (TRUE and TRUE), hence TRUE #&gt; [1] TRUE TRUE &amp; FALSE #&gt; [1] FALSE !TRUE #&gt; [1] FALSE !(TRUE &amp; TRUE) #&gt; [1] FALSE !(TRUE &amp; !TRUE) #&gt; [1] TRUE ((10%%2==0 &amp; 27%%2==0)) # equivalent to (TRUE and FALSE), hence FALSE #&gt; [1] FALSE ((10%%2==0 | 27%%2==0)) # equivalent to (TRUE or FALSE), hence TRUE #&gt; [1] TRUE 8.6 Writing and interpreting a condition Notice that what R looks for in a condition is a either a TRUE or a FALSE. If it encounters a TRUE, it executes the commands, otherwise, it doesn’t. Remember there are many ways to obtain one of these two logicals. Any of these ways will work as a condition. Here are examples of less trivial ways of writing a condition gains&lt;- c(10, 3,-5,0,-4,12,4) if (is.numeric(gains)) { print(&quot;Seems like it is a numeric vector...&quot;) } #&gt; [1] &quot;Seems like it is a numeric vector...&quot; # here, is.numeric(gains) evaluates to TRUE, hence, the code is executed! # the beginner&#39;s way would be to replace the condition by # if (class(gains)==&quot;numeric&quot;) if (!is.factor(gains)) { print(&quot;Yeah! We avoided the factor...&quot;) } #&gt; [1] &quot;Yeah! We avoided the factor...&quot; # the beginner would write if (class(gains)!=&quot;factor&quot;) "],
["conclusion.html", "Chapter 9 Conclusion", " Chapter 9 Conclusion We did a great book! "],
["references.html", "References", " References "]
]
